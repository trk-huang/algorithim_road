* [ ] # 排序算法概述

我们通常说的排序算法往往指的是内部排序算法，即数据是在内存中排序的。

排序算法通常分为两种：

1. 比较排序算法，时间复杂度是:O\(nlogn\)~O\(n2\),主要算法有冒泡排序，选择排序，插入排序，归并排序，堆排序，快速排序等。
2. 非比较排序算法，时间复杂度是O\(n\),主要的算法有计数排序，基数排序，桶排序。见下表：

| 排序算法 | 平均时间 | 最好时间 | 最差时间 | 辅助空间 | 稳定性 |
| :--- | :--- | :--- | :--- | :--- | :--- |
| 冒泡排序 | O\(n2\) | O\(n\) | O\(n2\) | O\(1\) | 稳定 |
| 归并排序 | O\(nlogn\) | O\(nlogn\) | O\(nlogn\) | O\(n\) | 稳定 |
| 堆排序 | O\(nlogn\) | O\(nlogn\) | O\(nlogn\) | O\(1\) | 不稳定 |
| 快速排序 | O\(nlogn\) | O\(nlogn\) | O\(n2\) | O\(nlogn\)~O\(n2\) | 不稳定 |
| 简单选择排序 | O\(n2\) | O\(n2\) | O\(n2\) | O\(1\) | 不稳定 |
| 直接插入排序 | O\(n2\) | O\(n\) | O\(n2\) | O\(1\) | 稳定 |
| 希尔排序 | O\(nlong\)~O\(n2\) | O\(n13\) | O\(n2\) | O\(1\) | 不稳定 |

> 注意：上表中，我们很容易忽略排序算法的稳定性

排序算法稳定性的简单定义为：如果Ai = Aj,排序前Ai在Aj之前，排序之后Ai还在Aj之前，这样算法是稳定的。通俗讲就是两个相等的数在排序算法之后，两者的相对顺序不变。

对于不稳定的排序算法，只要举出一个实例，即可说明它的不稳定性；而对于稳定的排序算法，必须对算法进行分析从而得到稳定的特性。需要注意的是，排序算法是否为稳定的是由具体算法决定的，不稳定的算法在某种条件下可以变为稳定的算法，而稳定的算法在某种条件下也可以变为不稳定的算法。

　　例如，对于冒泡排序，原本是稳定的排序算法，如果将记录交换的条件改成A\[i\] &gt;= A\[i + 1\]，则两个相等的记录就会交换位置，从而变成不稳定的排序算法。

　　其次，说一下排序算法稳定性的好处。**排序算法如果是稳定的，那么从一个键上排序，然后再从另一个键上排序，第一个键排序的结果可以为第二个键排序所用。**

